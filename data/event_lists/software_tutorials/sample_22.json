{
  "video_id": "software_tutorials_22",
  "summary": "A tutorial video explaining how to create a custom game saving system in Unity using binary formatting to overcome the limitations of PlayerPrefs.",
  "events_list": [
    {
      "event_id": "0",
      "start": "00:00:00.000",
      "end": "00:00:45.840",
      "video_caption": "The video begins with a black screen, followed by a scene from a classic video game featuring a character navigating through a vibrant, colorful environment with checkered ground and green grass. The game interface displays a score, time, and rings collected. The scene transitions to a menu screen with options such as 'Resume,' 'Options,' and 'Quit,' set against a backdrop of a detailed, animated town with buildings and trees. The Unity logo appears, indicating the game development platform. The video then showcases a more complex game environment with roller coasters, water slides, and various buildings, highlighting the game's intricate design. The Unity editor interface is displayed, showing a script with code for saving game data, emphasizing the technical aspects of game development. The video concludes with a focus on the code, highlighting the functionality of saving player preferences and game data.",
      "audio_caption": "The audio begins with calm music, likely for entertainment purposes, setting a relaxed mood with a focus on synthesized instruments and drums. Transitioning smoothly, a male speaker's voice introduces the topic, suggesting the discussion of a system for saving progress in video games and criticizing the built-in 'player prefs' as insufficient for complex games. After, he welcomes the audience to \"Game Dev Guide\" and transitions back to the calm music."
    },
    {
      "event_id": "1",
      "start": "00:00:45.840",
      "end": "00:01:26.971",
      "video_caption": "The video begins with a title screen displaying the text \"Building A Save System\" in red font on a plain white background. It then transitions to a screen with the text \"Holds Data We Want Saved\" in red font, accompanied by an icon of a document labeled \"C#\" and the words \"SAVE GAME\" in red font. The next frame shows the text \"SAVE GAME\" and \"SAVE DATA\" in red font, with a small icon labeled \"BINARY TEXT\" in the center. The video then introduces the concept of \"Three Main Components\" in red font, followed by a list of these components: \"Gameplay Data,\" \"Save Game Container,\" and \"Serialization System to write the Binary File,\" all in red font. The background remains consistently white throughout the video, emphasizing the textual information and icons related to building a save system for a game.",
      "audio_caption": "The clip begins with a male speaker introducing a project involving binary formatting and a safe game system. He outlines a three-part approach, involving game classes with data, a save game class for holding the data, and a serialization system. The speaker's tone is instructional and enthusiastic. The clip transitions into instrumental music with a techno style, creating an energetic mood, playing in the background as the male speaker continues talking."
    },
    {
      "event_id": "2",
      "start": "00:01:26.971",
      "end": "00:02:04.242",
      "video_caption": "The video showcases a computer screen displaying a software interface, likely a game development environment, with a dark theme. Initially, the screen is mostly black with a small section on the right showing a file directory with folders labeled \"Assets,\" \"Scenes,\" \"Scripts,\" \"Serialized,\" \"Plugins,\" \"TextMeshPro Pro,\" and \"Packages.\" The cursor moves to highlight the \"Assets\" folder, then to the \"Scripts\" folder, and finally to a specific script named \"SerializationManager.\" The scene transitions to a code editor where the \"SerializationManager\" script is open, displaying code in a dark theme with syntax highlighting. The code includes a class definition, a constructor, and a static method named \"Save.\" The cursor moves through the code, highlighting different parts, and the code editor shows a status bar at the bottom with various icons and a progress indicator. The video concludes with the cursor still within the code editor, indicating ongoing interaction with the script.",
      "audio_caption": "The clip begins with a male speaker explaining how to create a serialization script. He describes the process of creating a new folder and a new C# class. He then moves on to discuss writing a save method, explaining that it will take a save name string and the object that needs to be saved. The speaker mentions that the method will return a boolean value to confirm if the save was successful. Next, he mentions a separate method that will define a binary formatter, which will allow the speaker to define serialization surrogates for the formatter to use. The speaker mentions discussing this in more detail later, but for now, will return the binary formatter."
    },
    {
      "event_id": "3",
      "start": "00:02:04.242",
      "end": "00:02:59.199",
      "video_caption": "The video showcases a computer screen displaying a code editor with a dark theme, where a developer is working on a C# project. The code editor is open to a file named \"BinarySerializer.cs,\" and the developer is writing a method called \"Serialize\" within a class named \"BinarySerializer.\" The method is designed to serialize an object to a file using a specified path. The developer is using the \"Directory.CreateDirectory\" method to create a directory if it does not exist and then using the \"File.Create\" method to create a file at the specified path. The code includes a try-catch block to handle any exceptions that may occur during the file creation process. The developer is also using the \"BinaryFormatter\" class to serialize the object to the file. The code editor shows the file structure on the right side, with the \"BinarySerializer.cs\" file highlighted. The developer is using the \"Ctrl + Space\" shortcut to auto-complete the code. The video captures the developer's actions as they write and edit the code, with the code editor's interface and the developer's actions being the primary focus. The video provides a glimpse into the process of writing and debugging code in a C# project.",
      "audio_caption": "The clip begins with a male speaker discussing saving in a game, focusing on defining the path, creating a safe folder, and using a custom extension. He suggests using persistent data and then demonstrates how to create a file stream and use a binary formatter to serialize the object, followed by closing the file stream. A short pause is followed by the speaker beginning to describe a method called load, discussing how to check if the path exists and open a file stream. He details attempting to open the file, returning the saved object if it works, and implementing error catching to prevent code failure, returning a null object as an alternative."
    },
    {
      "event_id": "4",
      "start": "00:02:59.199",
      "end": "00:03:10.591",
      "video_caption": "The video showcases a computer screen displaying a code editor with a dark theme, where a user is working on a programming project. The code editor is open to a file named \"BinaryFormatter.cs,\" which contains a class with methods for reading and writing binary data. The user interacts with the editor by right-clicking on the file, opening a context menu, and selecting the \"Add\" option. This action brings up a dialog box titled \"Add New Item,\" where the user can choose from various templates to create a new file. The user selects the \"Class\" template and names the new file \"BinaryFormatter.cs.\" The video captures the user's actions as they navigate through the interface, highlighting the process of adding a new class file to the project. The environment is a typical development setup with a focus on the code editor and the file structure on the right side of the screen.",
      "audio_caption": "The clip begins with someone announcing the completion of a task and proposing the next one: \"With that finished, let's move on to the star of our show\". The speaker, who sounds male, continues by suggesting creating a new C# class and naming it \"safe data\"."
    },
    {
      "event_id": "5",
      "start": "00:03:10.591",
      "end": "00:03:40.520",
      "video_caption": "The video showcases a sequence of frames from a computer screen displaying a code editor, likely Visual Studio, with a focus on a C# script named \"SaveData.cs.\" The script is part of a Unity project, as indicated by the Unity-specific namespaces and attributes such as `[System.Serializable]`. The code editor interface includes a dark theme with syntax highlighting, and the right side of the screen shows a file explorer with various project files and folders, including \"Assets,\" \"Scripts,\" and \"Team Explorer.\" The code itself is being edited, with the cursor moving through different lines, suggesting active development or debugging. The environment is a typical software development setup, with the user interface elements and layout consistent with a professional coding environment. The video captures the process of writing or modifying code, with the focus on the script's structure and the use of static properties for data storage.",
      "audio_caption": "A single male speaker begins by defining a design pattern, specifically mentioning how to make it a singleton and create a reference. He moves on to discuss a save system, emphasizing that saved classes must be marked as \"serializable\". The speaker mentions adding the \"serializable attribute\" to the class header, indicating that anything in the save file should be serializable by the binary formatter. He concludes by saying that additional classes created with data stored will also need to be marked as serializable. The tone is informative and instructional."
    },
    {
      "event_id": "6",
      "start": "00:03:40.520",
      "end": "00:04:10.068",
      "video_caption": "The video showcases a sequence of actions within a programming environment, specifically Visual Studio, where a user is working on a C# project. Initially, the user is seen editing a class named \"SendData\" within the \"System.Serializable\" namespace, which includes properties such as \"public class SendData,\" \"private string Username,\" and \"private string Password.\" The user then navigates to the \"Add New Item\" dialog box, selecting \"Class\" and naming the new class \"PlayerProfile.\" Subsequently, the user edits the \"PlayerProfile\" class, adding properties like \"public class PlayerProfile,\" \"public string playerName,\" and \"public int experience.\" The user continues to add more properties to the \"PlayerProfile\" class, including \"public List<EnemyProfile> enemies\" and \"public List<EnemyProfile> bosses.\" Throughout the video, the user interacts with the Visual Studio interface, utilizing features such as the Solution Explorer and the Properties window. The environment remains consistent, with the dark theme of Visual Studio and the project structure visible on the right side of the screen. The video captures the user's methodical approach to structuring and organizing their code within the programming environment.",
      "audio_caption": "The audio begins with a male speaker outlining a plan to create a new class called \"player profile.\" He describes the class' purpose, stating it will \"hold some information about the player,\" such as their \"profile name,\" \"money,\" and \"experience level.\" He continues, explaining how the \"save data class\" will include a \"public player profile called profile,\" as well as some \"resources.\" The speaker supposes \"the player can buy toy cars and toy dolls with their currency\" and expresses a desire to \"keep track of how many of each toy they have.\" His tone is informative and instructional throughout."
    },
    {
      "event_id": "7",
      "start": "00:04:10.068",
      "end": "00:04:38.095",
      "video_caption": "The video showcases a user interface of a video game development environment, likely Unreal Engine, with a focus on creating and managing game profiles. Initially, the screen displays a main menu with two prominent buttons: \"New Game\" in green and \"Load Game\" in blue, set against a dark background. The user navigates to the \"New Game\" option, leading to a profile creation screen where the user inputs the name \"Matt\" and clicks \"Start.\" The interface then transitions to a profile management screen for \"Matt,\" showing a balance of 1000g and options to \"Work,\" \"Buy Car,\" or \"Buy Doll.\" The user selects \"Work,\" and the balance increases to 1200g, with the number of \"Car Toys\" incrementing to 2. Subsequently, the user chooses \"Buy Doll,\" reducing the balance to 200g and increasing the \"Doll Toys\" count to 5. The video concludes with the user's profile details displayed, including the updated balance and toy counts, within the same dark-themed interface. Throughout the video, the right side of the screen consistently shows a project browser with various folders and files, indicating the development environment's organizational structure.",
      "audio_caption": "The audio clip begins with a male speaker describing a UI he has built for a game, mentioning features like starting a new game or loading a save. He explains the process of inputting a player's name when starting a new game, which gets saved to the profile data along with default variables. The speaker details the second screen where players can view their name and has buttons to buy toys or work. The sound of a gentle, simple, possibly electronic-based track plays softly. The speaker continues to explain how clicking the work button grants currency and experience, while buying toys spends currency and gains a toy. He concludes by stating that the data is being tracked in the UI."
    },
    {
      "event_id": "8",
      "start": "00:04:38.095",
      "end": "00:05:04.169",
      "video_caption": "The video showcases a sequence of frames from a video game development environment, likely Unity, where a game's save data is being managed and updated. Initially, the video displays a code editor with a script that includes methods for saving and updating game data, such as 'Work', 'BuyToyCar', and 'BuyToyDoll'. The code is written in C# and involves saving the player's profile data, including currency and experience, to a file named 'Save.save'. The scene then transitions to a game interface where a player named 'Matt' has 400g of currency and 19 experience points. The interface shows options to 'Work', 'Buy Car', and 'Buy Doll', with corresponding toy counts displayed. The player's currency and experience points decrease as they perform actions like 'Work' and 'Buy Doll', reflecting the game's mechanics. The video then shows the game's main menu with 'New Game' and 'Load Game' options, followed by a return to the game interface where the player's currency and experience points have been updated. The video concludes with the game interface displaying the updated player stats, indicating the successful implementation of the save and update functionality within the game.",
      "audio_caption": "The audio clip begins with a male speaker explaining that pressing buttons updates data in their save system. He continues, describing the save and load functions, mentioning how the load button \"simply replaces the save data class\" and updates the UI. He concludes by stating that the save system seems to be working as expected. The overall speaking tone is informative and relatively neutral."
    },
    {
      "event_id": "9",
      "start": "00:05:04.169",
      "end": "00:05:32.806",
      "video_caption": "The video begins with a computer screen displaying a Unity game development environment, where a user is interacting with a game scene featuring a room with a carpeted floor, a bed, and various objects such as a gift box, a toy car, and plush toys. The user is seen adjusting settings in a menu, specifically modifying the number of car and doll toys. The scene transitions to a gameplay view where the plush toys and toy car are animated, moving around the room. The video then shows a message on the screen stating, \"The Binary Formatter does not serialize Unity Classes by default,\" indicating a technical limitation within the Unity engine. This is followed by another message, \"So, we can't just add the GameObjects to our save data class and expect it to save,\" explaining the consequence of this limitation. The video concludes with a blurred view of the game scene, emphasizing the technical discussion rather than the gameplay itself.",
      "audio_caption": "The clip begins with a male speaker saying, \"But we're not done yet,\" followed by, \"Right.\" He continues explaining that he's taken a toy box analogy further, and the prototype has toys that can be spawned and moved around. He discusses wanting the save system to remember which toy to save and where it is in the play space, acknowledging the increasing complexity. He notes that the binary formatter doesn't support Unity classes such as game objects, transforms, or Vector3s out of the box, which means the system cannot simply save a list of game objects. The speaker sounds calm and informative throughout the clip."
    },
    {
      "event_id": "10",
      "start": "00:05:32.806",
      "end": "00:06:04.232",
      "video_caption": "The video showcases a series of frames focusing on a computer screen displaying code written in C#. The code is part of a Unity project, as indicated by the use of Unity-specific namespaces such as 'using UnityEngine;' and 'using System.Collections.Generic;'. The code includes an enumeration named 'ToyType' with three options: 'Car', 'Penguin', and 'Pig'. Additionally, there is a class named 'ToyData' with properties like 'id', 'toyType', 'position', and 'rotation', all marked with the '[System.Serializable]' attribute, which is used to enable serialization of the class. The video also shows a class named 'SaveData' with properties like 'profile' and 'toyCars', which is a list of 'ToyData' objects. Throughout the video, the code is highlighted and annotated with white arrows pointing to specific lines, and text overlays provide explanations about the code's functionality, such as the use of 'id' for restoring references between game objects. The background remains consistent, showing a dark-themed code editor interface with syntax highlighting, and the focus is on the code itself, with no visible people or other environmental details. The video transitions between different parts of the code, zooming in and out to emphasize specific sections and their attributes.",
      "audio_caption": "The clip starts with someone explaining that they've created a custom class for their toys and added a list of them to their save data. The speaker, a male, mentions the class is marked as serializable and has an enum for the toy type, a string ID, a vector 3 for position, and a quaternion for rotation, giving it an ID so other objects that rely on it can get a reference upon loading again. He then explains that he stores position and rotation because they're going to need the serialization surrogates mentioned earlier. The clip ends with a short indistinct noise."
    },
    {
      "event_id": "11",
      "start": "00:06:04.232",
      "end": "00:06:54.498",
      "video_caption": "The video begins with a solid red background displaying the text \"Serialization Surrogates\" in white, followed by a subtitle \"tell the Binary Formatter how to serialize a class\" in smaller white text. The scene transitions to a computer screen showing a code editor with a file named \"VectorSerializationSurrogate.cs\" open. The code editor is part of a larger development environment, with tabs for other files visible at the top. The code within the editor is written in C# and includes a class named \"VectorSerializationSurrogate\" that implements the \"ISerializationSurrogate\" interface. The code defines methods for serialization and deserialization of vector objects. The video then shows a continuation of the code editor, displaying additional code for a class named \"QuaternionSerializationSurrogate\" that also implements the \"ISerializationSurrogate\" interface. The code includes methods for serialization and deserialization of quaternion objects. The video concludes with a view of the code editor showing a method named \"GetBinaryFormatter\" that sets up a BinaryFormatter with a SurrogateSelector, adding surrogates for Vector3 and Quaternion types. The overall theme of the video is to demonstrate how to use serialization surrogates in C# to handle the serialization of specific data types.",
      "audio_caption": "The clip begins with a male speaker describing a \"serialization surrogate,\" explaining its use to instruct binary formatters on how to serialize classes that aren't naturally serializable. He goes on to mention the need to create surrogates for vector 3s and quaternions, utilizing the \"I Serialization Surrogate interface.\" The male speaker further elaborates on handling data for each type and adding the surrogates to a list. He then specifies instructing the binary formatter to use the surrogates. The speaker says it could be possible to extend this further to create surrogates for all of the properties of a monobehaviour to make it completely serializable. However, he states that he tries to limit the data he handles as much as possible."
    },
    {
      "event_id": "12",
      "start": "00:06:54.498",
      "end": "00:07:47.946",
      "video_caption": "The video begins with a view of a computer screen displaying a Unity game development environment. The editor shows a script named \"Modifier\" with various methods such as \"Start,\" \"Update,\" and \"OnDestroy.\" The code includes references to Unity's serialization and event handling, with comments indicating the purpose of each method. The Unity editor's interface is visible, including the \"Hierarchy,\" \"Inspector,\" and \"Project\" panels, with a project named \"Team Explorer\" open. The scene then transitions to a 3D-rendered room with a cozy atmosphere, featuring a bed, a nightstand, and a patterned carpet. On the carpet, there are several plush toys, including a penguin and a few pink creatures, along with a toy car and an open box with a floral pattern. The room is well-lit, with sunlight streaming in through a window, creating a warm and inviting environment. The plush toys appear to be in motion, suggesting they are part of an interactive game or animation within the Unity project.",
      "audio_caption": "The clip starts with a male speaker who has a friendly and informative tone. He talks about telling toys to add themselves to save data when they are spawned and about the game object destroying itself when the load event is called. He also mentions updating their data when they are interacted with and how the game will spawn each toy based on its enum, placing it in its save position and rotation when loaded. He then says \"If we try it out,\" and a subtle musical background begins to play, which sounds like a mellow, ambient track. The speaker then goes on to say \"you can see our system successfully saves and loads our more complex toy data, thanks to our serialization surrogates.\""
    },
    {
      "event_id": "13",
      "start": "00:07:47.946",
      "end": "00:09:00.677",
      "video_caption": "The video showcases a detailed process of saving and loading a game within a Unity game development environment. It begins with a screenshot of a game's save menu, displaying various save files and their respective dates and times. The scene transitions to the Unity editor, where the user navigates through the project's hierarchy and inspects the 'SaveManager' script, which contains methods for saving and loading game data. The user then adds a 'Canvas' component to the scene, followed by a 'TextMeshPro' component to display the save file names. The video progresses to show the user implementing the 'OnSave' and 'ShowLoadScreen' methods within the 'SaveManager' script, which handle the saving and loading functionalities. The user then runs the game, revealing a 3D environment with a 'Choose A Game To Load' menu, listing various save files. The video concludes with the user selecting a save file, demonstrating the successful implementation of the save and load features within the game. Throughout the video, the Unity editor interface, including the project window, scene view, and inspector, is prominently displayed, providing a comprehensive view of the development process.",
      "audio_caption": "The clip begins with a male speaker discussing a technical problem with a \"current system\" that handles a \"single save file at a time.\" He explains that it is ideal to support multiple save files, then outlines how to create a \"save manager class.\" The male speaker continues to describe the save manager class, explaining that it will need a UI. He ends by saying that multi-file saving is \"easy with just a few more simple steps.\" The male speaker summarizes the information, stating that the process is a flexible way to handle saving in a game."
    },
    {
      "event_id": "14",
      "start": "00:09:00.677",
      "end": "00:09:40.058",
      "video_caption": "The video begins with a blurred background featuring a group of people sitting around a table, engaged in an activity that involves colorful objects, possibly toys or game pieces. Overlaid on this scene is a text box with the heading \"In Summary,\" followed by two bullet points. The first bullet point states, \"Using the binary formatter is an extremely flexible and fast way to handle saving game data.\" The second bullet point reads, \"This system means that you don't have to worry too much about parsing or casting save data.\" The text is white with a red heading, and the background remains blurred throughout this segment, emphasizing the text's importance.\n\nThe video then transitions to a clean, minimalist design with a light gray background. In the top left corner, there is a red square icon featuring a white curly brace symbol, suggesting a coding or programming theme. At the bottom of the screen, a red banner with white text reads, \"Subscribe For More Videos!\" This call to action is clear and direct, encouraging viewers to engage further with the content creator's channel. The overall design is simple and uncluttered, focusing on the subscription message without any additional visual distractions.",
      "audio_caption": "The audio clip begins with a male speaker discussing the redesign of data management in a code base and its benefits over writing code for individual data points. He expresses hope that the listener finds the information useful and encourages them to share new learnings and potential applications in their game. He then encourages subscribing for game dev tips and tutorials, invites exploring other videos on the channel, and expresses gratitude for listening, promising a return next time."
    }
  ]
}